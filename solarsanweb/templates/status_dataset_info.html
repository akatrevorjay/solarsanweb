{% from "bootstrap/macros.html" import alert  %}
{% from "bootstrap/forms/macros.html" import field, input  %}

{% if action == "list" %}
<script type="text/javascript">
/*
 * Navbar "tabs"
 */

$(".dataset-info-nav > li")
    .click(function() {
        $(this).parent().children(".active").removeClass("active", "fast");
        $(this).addClass("active");

        var url = "{{ url('solarsan.views.status_dataset_info', dataset=dataset, action='list') }}";
        url = url.replace(/\/list/i, "/"+$(this).find('a:first').html().toLowerCase());

        $.ajax({type: "GET",
                url: url,
                context: $(this),
                }).done(function(data) { $("#dataset-info-content").html(data); });
    });
// Act as if the first dataset has been clicked
$(".dataset-info-nav > li").first().click();

</script>

<div class="row">
    <div class="navbar">
        <div class="navbar-inner">
            <div class="container" style="width: auto;">
                <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </a>
                <a class="brand" href="#">{{ dataset.name }}</a>
                <div class="nav-collapse">
                    <ul class="nav dataset-info-nav">
                        {% set tabs = ['health', 'snapshots', 'cron', 'cluster', 'backup'] %}
                        {% for t in tabs %}
                        <li{% if action == t %} class="active"{% endif %}><a href="#">{{ t|capitalize }}</a></li>
                        {% endfor %}
                    </ul>

                    <ul class="nav pull-right">
                        {#<li><a href="#">Link</a></li>#}
                        {#<li class="divider-vertical"></li>#}

                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Services <b class="caret"></b></a>
                            <ul class="dropdown-menu">
                                <li><a href="#">Automatic Snapshot</a></li>
                                <li><a href="#">Online Backup</a></li>
                                {#<li class="divider"></li>
                                <li><a href="#">Separated link</a></li>#}
                            </ul>
                        </li>         
                    </ul>
                </div><!-- /.nav-collapse -->
            </div>
        </div><!-- /navbar-inner -->
    </div><!-- /navbar -->
</div>

<div class="row">
    <div id="dataset-info-content" class="hero-unit">
        content
    </div>
</div>

{% endif %}

{% if action == "health" %}
<pre>

	Pool "{{ dataset.pool.name }}"
		- Health: {{ dataset.pool.health }}


    Dataset "{{ dataset.name }}":
       Used: {{ dataset.used }} / {{ dataset.available }}
		- By children: {{ dataset.usedbychildren }}
		- By snapshots: {{ dataset.usedbysnapshots }}

</pre>
{% endif %}

{% if action == "cluster" %}
<pre>
##### Manage mirror

    Show mirror cluster information
        In cluster? Yes/No
        IPs of all clustered nodes

    Check health of cluster
        $ gluster peer status
        $ crm_mon
        $ ip addr

        ping solarsan services
        ping solarsan

        IMPORTANT: Test file replication per mirror volume both both sides. Need to do this on a scheduled task as well, rather often.
            Each mirror volume will have a .solarsan/repltest folder meant for this.
            Every minute (or more), write to this folder with a UUID filename (or file contains random data, and filename is sha1sum of data)
            If write failed, send out event saying so much, email support and configured client alerts email address
            Send out celery event saying a repltest file x was just created, and to report back with status of being able to read this file
            If a node does not reply soon (ie, 15-30s), then mark it as down and in need of resync

            Need to monitor gluster logs for:
                File/Directory Split Brain
                    -- (later) Before attempting to fix, create snapshot
                    -- Easy way to know which unit has the correct file is to keep track of when each San was primary.
                    -- Whoever was primary at the given point in time that split brain occurred is the one who has the winning copy.
                    -- Just delete the file from the seconday unit, trigger resync on it (limit if you can)
                Failures
                    -- If severe enough, take self out of cluster

            Need to find a way to see if a file on a mirror volume is in sync between the nodes
            Collect a list of files not in sync, try to force a resync, but we need to be able to limit this somehow, currently gluster does not deal with resyncs and anything else very well, 

        (later) check recent load avgs and IO avgs against what is considered "normal"
        (later) infiniband diagnostics

##### Cluster setup from scratch

    Check if clustering is already active, error if so
        How should the cluster information be stored?
            For version 1, the database sounds fine to me.
                After version 1 if anything relies on the db it needs to check for corrupt tables and repair them (ubu/deb init scripts do something of the like of this already, see if this good enough.
            Could also be stored as a configuration file.

    Setup clustering stack (originally only for up to two units)
        What cluster stack should we use 100% from now on?
            Corosync is nice, but rather costly on time required to configure.
            I think it may be beneficial to handle our own clustering stack, very small and only containing the basics that we need.
                Celery for async tasks
                    Cluster status updates, Cluster ping/pongs, Cluster checks
                Are there modules available that already manage virtual IPs ala ucarp etc?
                    If not iterpipe to iproute2 or just run a vip-up script?
                It would be possible to use Celery for pings, when a certain amount of time elapses without successful pings, then takeover.

        Configure HA IP between both unirs

    Setup rabbitmq cluster for fault tolerance (no SPOF!)
    Setup solarsan service communication, verify it works

    Write node information in DB

    Mark unit as in cluster

##### Setup gluster mirror
1. Ensure glusterfs-server is running
2. Configure peers (via avahi or netbeacon, one click cluster)

</pre>
{% endif %}

{% if action == "cron" %}
<div class="row">
<script type="text/javascript">

$('.cronselect').each(function() {
    $(this).cron({
            initial: "42 3 * * 5",
            onChange: function() {
                $(this).parent().find("input").val($(this).cron("value"));
            }
        });
});

</script>

<form class="form-horizontal">
<fieldset>
<legend>Schedule</legend>

<h3>Automated Snapshots</h3>
{{ field(dataset_cron_form.auto_snapshot_enabled) }}
<div class="cronselect" style="display: inline;"></div>

<a href="#" onclick="$(this).next().toggle().prev().toggle();">advanced</a>
{{ field(dataset_cron_form.auto_snapshot_crontab) }}

<h3>Integrated Online Backup</h3>
{{ field(dataset_cron_form.online_backup_enabled) }}
<div class="cronselect" style="display: inline;"></div>

<a href="#" onclick="$(this).next().toggle().prev().toggle();">advanced</a>
{{ field(dataset_cron_form.online_backup_crontab) }}

<div class="form-actions">
<button type="submit" class="btn btn-primary">Save</button>
<a href="#" class="btn">Cancel</a>
</div>

</form>

</div>

{% endif %}

{% if action == "backup" %}
<script type="text/javascript">

$(".online_backup").each(function() {
    // assign default values
    $("textarea, input", this).DefaultValue();

    // datasets drop
    $(".datasets", this).droppable({
            activeClass: "ui-state-hover",
            hoverClass: "ui-state-active",
            accept: ":not(.ui-sortable-helper)",
            drop: function( event, ui ) {
                $( this ).find( ".placeholder" ).remove();
                //console.log(ui);
                
                $( "<li></li>" ).text( ui.helper.text() ).button().css("padding", "5").appendTo(this);
                
                //$( "<div></div>" ).text( ui.draggable.find("a").text() ).button().appendTo( this );
            },
    }).sortable({
        items: "li:not(.placeholder)",
        tolerance: 'pointer',
        sort: function() {
            // gets added unintentionally by droppable interacting with sortable
            // using connectWithSortable fixes this, but doesn't allow you to customize active/hoverClass options
            $( this ).removeClass( "ui-state-default" );
        },
        //placeholder: "ui-state-highlight",
        //revert: true,
        //axis: 'x',
        //containment: 'parent',
    });
    //$(".datasets", this).disableSelection();
});

</script>

<div class="online_backup" style="padding: 10px;">
    enter in locsol backup key, drag and drop datasets from the left to backup<br />
    show graph with space available / remaining<br/>
    show backup status<br />
    <form>
        <input type="text" name="username" label="Username" />
        <textarea name="key" style="width: 100%" label="Online Backup Key"></textarea>
        <div class="datasets ui-state-default" style="width: 100%; height: 100px; overflow: hidden;" label="Datasets">
            <ul></ul>
        </div>
        <input type="submit" value="Save"/>
    </form>
</div>
{% endif %}

{% if action == "snapshots" %}

<table id="list1"></table>
<div id="pager1"></div>

<script type="text/javascript">

$("#list1").jqGrid({ url: '{{ url('solarsan.views.status_dataset_info', dataset=dataset.name, action="snapshots_xml_jqgrid") }}',
    datatype: "xml",
    colNames: ['Name', 'Created', 'Used', 'Avail' ],
    colModel: [
        {name:'name', index:'name'},
        {name:'created', index:'created', width: 110},
        {name:'used', index:'used', width: 25},
        {name:'available', index:'available', width: 25}, ],
    rowNum: 20, rowList: [10,20,30],
    autowidth: true,
    height: 250,
    pager: '#pager1',
    sortname: 'name',
    viewrecords: true,
    sortorder: "desc"}).navGrid('#pager1', {edit:false, add:true, del:true});

</script>
{% endif %}

{% if action == "snapshots_xml_jqgrid" %}
<rows>
    {% for snapshot in dataset.snapshots()|sort(attribute='name') %}
    <row>
        <cell><![CDATA[{{ snapshot.basename }}]]></cell>
        <cell>{{ snapshot.creation }}</cell>
        <cell>{{ snapshot.used }}</cell>
        <cell>{{ dataset.available }}</cell>
    </row>
    {% endfor %}
</rows>
{% endif %}
